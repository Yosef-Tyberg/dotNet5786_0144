
using DalApi;
using DO;

namespace DalTest;

/*this file was generated by chatgpt using the following prompts:
 * 1)
 * now, based on the classes i've given you, i would like you to create a test class for this project. 
 * first, within DalTest, I want to create an initialization class which will initialize the database with legal values. 
 * Data must be valid, legal, and logically related, maintaining referential integrity.
 * I then pasted in the data requirements from the document we were given.
 * 2)
 * to be clear there are two files in total. the first, called Initialization, contains the methods to populate 
 * the database + all helper methods needed for that task. finally it contains a method named Do which contains 
 * all the population methods - so when called it will populate the database fully. 
 * the second file is called Program and contains a Main function, which starts off by calling Initialization.Do 
 * for now i'd like to focus on the initialization file. first of all, there is not yet a factory method, 
 * nor do i wish to implement one at this time. instead, the class should contain the fields: private static ICourier? s_dalCourier; 
 * private static IDelivery? s_dalDelivery; private static IOrder? s_dalOrder; private static IConfig? s_dalConfig; 
 * and use those to access the CRUD and config implemented methods. 
 * next, I would like the names of the couriers to be actual names, not just courierI. 
 * I would like to ensure the numbers regarding the entities are accurate, so instead of using 
 * weighted probabilities to get the right distribution, please make the distribution explicit.
 */

/// <summary>
/// Database initialization helper that populates the DAL with valid, consistent data.
/// Set DAL instances via <see cref="InitWithDalInstances"/> and then call <see cref="Do"/>.
/// </summary>
public static class Initialization
{
    // DAL instances - set these before calling Do()
    private static ICourier? s_dalCourier;
    private static IDelivery? s_dalDelivery;
    private static IOrder? s_dalOrder;
    private static IConfig? s_dalConfig;

    // deterministic random for reproducible test data
    private static readonly Random s_rnd = new Random(123456);

    // explicit counts / distributions (as requested)
    private const int CouriersCount = 20;
    private const int CouriersActiveCount = 17;
    private const int CouriersInactiveCount = CouriersCount - CouriersActiveCount; // 3

    private const int OrdersCount = 50;
    private const int OrdersOpenCount = 20;
    private const int OrdersInProgressCount = 10;
    private const int OrdersClosedCount = 20; // totals 50

    // explicit closed-end-type distribution (sum must equal OrdersClosedCount)
    private const int Closed_Delivered = 14;
    private const int Closed_Failed = 1;
    private const int Closed_Cancelled = 1;
    private const int Closed_CustomerRefused = 2;
    private const int Closed_RecipientNotFound = 2;

    //legal ID limits
    private const int minId = 200000000;
    private const int maxId = 999999999;
    // small test address model
    private record TestAddress(string Label, double Lat, double Lon);



    /// <summary>
    /// Populates the DAL fully (config, couriers, orders, deliveries).
    /// Requires that <see cref="InitWithDalInstances"/> was called first.
    /// </summary>
    public static void Do(ICourier courier, IOrder order, IDelivery delivery, IConfig config)
    {
        s_dalCourier = courier ?? throw new ArgumentNullException(nameof(courier));
        s_dalOrder = order ?? throw new ArgumentNullException(nameof(order));
        s_dalDelivery = delivery ?? throw new ArgumentNullException(nameof(delivery));
        s_dalConfig = config ?? throw new ArgumentNullException(nameof(config));

        // 1. Reset and initialize config first
        s_dalConfig!.Reset();
        InitializeConfig(s_dalConfig);

        // 2. Prepare a short list of real-ish addresses (labels + coordinates)
        var addresses = PrepareAddresses(s_dalConfig);

        // 3. Create Couriers (explicit distribution)
        var createdCouriers = CreateCouriers(s_dalCourier!, s_dalConfig, CouriersCount, CouriersActiveCount);

        // 4. Create Orders (pass Id = 0 to allow DAL auto-generation). 50 orders.
        var createdOrders = CreateOrders(s_dalOrder!, addresses, OrdersCount, s_dalConfig!.Clock);

        // 5. Create Deliveries (assign courier->order respecting distances and no overlapping)
        CreateDeliveries(s_dalDelivery!, s_dalCourier!, s_dalOrder!, s_dalConfig!, createdCouriers, createdOrders);

        // Done
    }

    // -----------------------------
    // Internal helpers
    // -----------------------------

    private static void InitializeConfig(IConfig cfg)
    {
        // Example company coordinates - change as appropriate for your tests
        cfg.CompanyFullAddress = "Downtown (test) - company HQ";
        cfg.Latitude = 31.771959;
        cfg.Longitude = 35.217018;

        // reasonable urban speed assumptions
        cfg.AvgCarSpeedKmh = 40.0;
        cfg.AvgMotorcycleSpeedKmh = 35.0;
        cfg.AvgBicycleSpeedKmh = 15.0;
        cfg.AvgWalkingSpeedKmh = 5.0;

        // Delivery limits & thresholds
        cfg.MaxGeneralDeliveryDistanceKm = 10.0; // global max radius
        cfg.MaxDeliveryTimeSpan = TimeSpan.FromHours(2);
        cfg.RiskRange = TimeSpan.FromMinutes(10);
        cfg.InactivityRange = TimeSpan.FromMinutes(30);

        // set test clock to now (or any fixed time)
        cfg.Clock = DateTime.Now;
    }

    /// <summary>
    /// Prepare a short fixed list of addresses near the company location.
    /// These coordinates are representative and intended for local testing — replace as needed.
    /// </summary>
    private static List<TestAddress> PrepareAddresses(IConfig cfg)
    {
        // A small set of nearby addresses (lat, lon) relative to the company coords.
        // Keep addresses within the global max radius where possible.
        return new List<TestAddress>
        {
            new TestAddress("Ben Yehuda Street", 31.781500, 35.217600),
            new TestAddress("Jaffa Road", 31.784637, 35.215046),
            new TestAddress("Mahane Yehuda", 31.784700, 35.207300),
            new TestAddress("Emek Refaim - German Colony", 31.757919, 35.218139),
            new TestAddress("Givat Shaul", 31.787128, 35.190108),
            new TestAddress("Hebron Road (central)", 31.766509, 35.225938),
            new TestAddress("Ein Kerem (outer)", 31.759164, 35.143000),
            new TestAddress("Knesset area", 31.776670, 35.205280)
        };
    }

    /// <summary>
    /// Create a fixed set of couriers. Distribution is explicit:
    /// - CouriersCount total
    /// - exactly <paramref name="activeCount"/> active couriers, the rest inactive.
    /// - delivery types distributed evenly (as even as possible).
    /// </summary>
    private static List<Courier> CreateCouriers(ICourier courierDal, IConfig cfg, int courierCount, int activeCount)
    {
        var output = new List<Courier>(courierCount);

        // explicit real-ish names list (enough unique names)
        var names = new[]
        {
            "Ariel Cohen", "Maya Levi", "Noam Shalev", "Lior Kaplan", "Yael Barak",
            "Ethan Mizrahi", "Nadav Rosen", "Shira Gold", "Omer Katz", "Talia Aviv",
            "Daniel Harel", "Roni Peretz", "Galit Stern", "Itai Levy", "Rivka Eitan",
            "Avi Ben-David", "Hannah Azulay", "Eitan Strauss", "Lina Doron", "Yonatan Amir"
        };

        // Uniformly assign delivery types: ensure as-even-as-possible distribution
        var types = Enum.GetValues(typeof(DeliveryTypes)).Cast<DeliveryTypes>().ToArray();
        var assignedTypes = new List<DeliveryTypes>();
        for (int i = 0; i < courierCount; i++)
        {
            assignedTypes.Add(types[i % types.Length]); // cycles to produce even distribution
        }
        // shuffle assigned types slightly to distribute across indices
        assignedTypes = assignedTypes.OrderBy(_ => s_rnd.Next()).ToList();

        // company global max used for per-courier personal max selection
        var globalMax = cfg.MaxGeneralDeliveryDistanceKm ?? 10.0;

        //current (highest) id for calculation below
        int curId = minId;
        for (int i = 0; i < courierCount; i++)
        {
            //to prevent id collisions cheaply, we choose ids in increasing order. min increase is 1. max is (remaining range)/(remaining couriers)
            //to avoid running out of space
            int id = curId + s_rnd.Next(1, (maxId - curId) / (courierCount - i));
            curId = id;
            
            var fullName = names[i % names.Length];

            // personal max: choose randomly but <= global max. Some couriers may leave it null.
            double? personalMax = null;
            if (s_rnd.NextDouble() < 0.8) // 80% of couriers have a personal max
            {
                // between 1.0 km and globalMax
                var val = 1.0 + s_rnd.NextDouble() * Math.Max(0.0, globalMax - 1.0);
                personalMax = Math.Round(val, 2);
            }

            // employment start earlier than the system clock
            var start = cfg.Clock.AddDays(-s_rnd.Next(1, 365 * 3)).AddMinutes(-s_rnd.Next(0, 60 * 24));

            var courier = new Courier(
                Id: id,
                FullName: fullName,
                MobilePhone: RandomPhone(),
                Email: $"{SanitizeEmailLocalPart(fullName)}@example.test",
                Password: "pwd", // simple password for test data
                Active: true, // temporarily set true; we will mark some inactive explicitly below
                DeliveryType: assignedTypes[i],
                EmploymentStartTime: start,
                PersonalMaxDeliveryDistance: personalMax
            );

            courierDal.Create(courier);
            output.Add(courier);
        }

        // Explicitly set exactly 'activeCount' active couriers and the rest inactive:
        // We already added all active=true; now pick couriers to mark inactive until count matches.
        var toMarkInactive = output.OrderBy(_ => s_rnd.Next()).Take(CouriersInactiveCount).ToList();
        foreach (var c in toMarkInactive)
        {
            var updated = c with { Active = false, EmploymentStartTime = c.EmploymentStartTime.AddYears(-1) };
            courierDal.Update(updated); // update uses your DAL's update pattern
            // replace in output list
            var index = output.FindIndex(x => x.Id == c.Id);
            if (index >= 0) output[index] = updated;
        }

        // If exact active count must be ensured, we can enforce it:
        // Validate counts
        var finalActive = output.Count(c => c.Active);
        if (finalActive != activeCount)
        {
            // adjust deterministically: if too many active, deactivate earliest ones; if too few, activate some.
            if (finalActive > activeCount)
            {
                var toDeactivate = output.Where(c => c.Active).OrderByDescending(c => c.EmploymentStartTime).Take(finalActive - activeCount).ToList();
                foreach (var c in toDeactivate)
                {
                    var upd = c with { Active = false };
                    courierDal.Update(upd);
                    var idx = output.FindIndex(x => x.Id == c.Id);
                    if (idx >= 0) output[idx] = upd;
                }
            }
            else if (finalActive < activeCount)
            {
                var toActivate = output.Where(c => !c.Active).OrderBy(c => c.EmploymentStartTime).Take(activeCount - finalActive).ToList();
                foreach (var c in toActivate)
                {
                    var upd = c with { Active = true };
                    courierDal.Update(upd);
                    var idx = output.FindIndex(x => x.Id == c.Id);
                    if (idx >= 0) output[idx] = upd;
                }
            }
        }

        return output;
    }

    /// <summary>
    /// Create orders (Id = 0 so DAL assigns IDs). Returns the list of orders as read back from DAL (with assigned Ids).
    /// Explicitly creates OrdersCount orders; later we will treat first N as open / in-progress / closed.
    /// </summary>
    private static List<Order> CreateOrders(IOrder orderDal, List<TestAddress> addresses, int totalCount, DateTime clock)
    {
        var created = new List<Order>(totalCount);
        var orderTypes = Enum.GetValues(typeof(OrderTypes)).Cast<OrderTypes>().ToArray();

        for (int i = 0; i < totalCount; i++)
        {
            var addr = addresses[s_rnd.Next(addresses.Count)];

            var otype = orderTypes[s_rnd.Next(orderTypes.Length)];
            var verbal = otype == OrderTypes.Pizza ? "Pizza order" : "Falafel order";

            var openTime = clock.AddMinutes(-s_rnd.Next(1, 60 * 24 * 14)); // opened sometime within last 14 days

            var order = new Order(
                Id: 0, // DAL assigns
                OrderType: otype,
                VerbalDescription: $"{verbal} #{i + 1}",
                FullOrderAccess: Guid.NewGuid().ToString("N"),
                Latitude: addr.Lat,
                Longitude: addr.Lon,
                CustomerFullName: $"Customer {i + 1}",
                CustomerMobile: RandomPhone(),
                Volume: Math.Round(0.1 + s_rnd.NextDouble() * 3.0, 3),
                Weight: Math.Round(0.1 + s_rnd.NextDouble() * 10.0, 3),
                Fragile: s_rnd.NextDouble() < 0.15,
                Height: Math.Round(5 + s_rnd.NextDouble() * 50, 2),
                Width: Math.Round(5 + s_rnd.NextDouble() * 50, 2),
                OrderOpenTime: openTime
            );

            orderDal.Create(order);
            created.Add(order); // note: these instances may not have real IDs; we'll read them back below
        }

        // Read back all orders from DAL to obtain real assigned IDs and return them sorted by open time
        var ordersFromDal = orderDal.ReadAll().OrderBy(o => o.OrderOpenTime).ToList();
        return ordersFromDal;
    }

    /// <summary>
    /// Creates deliveries based on three sets:
    /// - OrdersInProgressCount orders receive in-progress deliveries (no end time).
    /// - OrdersClosedCount orders receive closed deliveries with explicit end-type distribution.
    /// - OrdersOpenCount remain open (no delivery).
    /// This method uses only the DAL APIs to create deliveries.
    /// </summary>
    private static void CreateDeliveries(
        IDelivery deliveryDal,
        ICourier courierDal,
        IOrder orderDal,
        IConfig cfg,
        List<Courier> createdCouriers,
        List<Order> ordersFromDal)
    {
        // Defensive reads from DAL (readall returns safe copy as you said)
        var couriers = courierDal.ReadAll();
        var orders = new List<Order>(ordersFromDal); // local mutable copy

        // Partition orders explicitly:
        // - first OrdersOpenCount stay open (no delivery)
        // - next OrdersInProgressCount will have in-progress deliveries
        // - next OrdersClosedCount will have closed deliveries (with explicit end-type counts)
        if (orders.Count < OrdersCount)
            throw new InvalidOperationException("Not enough orders in DAL to partition as requested.");

        var openOrders = orders.Take(OrdersOpenCount).ToList();
        var inProgressOrders = orders.Skip(OrdersOpenCount).Take(OrdersInProgressCount).ToList();
        var closedOrders = orders.Skip(OrdersOpenCount + OrdersInProgressCount).Take(OrdersClosedCount).ToList();

        // track per-courier schedule to prevent overlaps: list of (start,end)
        var courierSchedules = couriers.ToDictionary(c => c.Id, c => new List<(DateTime Start, DateTime? End)>());

        // helper: haversine aerial distance
        static double AerialKm(double lat1, double lon1, double lat2, double lon2)
        {
            const double R = 6371.0;
            double d2r(double deg) => deg * Math.PI / 180.0;
            var dLat = d2r(lat2 - lat1);
            var dLon = d2r(lon2 - lon1);
            var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2)
                    + Math.Cos(d2r(lat1)) * Math.Cos(d2r(lat2))
                    * Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
            var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            return R * c;
        }

        // helper: find an available courier for an order at desiredStart respecting distances & no overlaps
        Courier? FindAvailableCourier(Order order, DateTime desiredStart)
        {
            var companyLat = cfg.Latitude!.Value;
            var companyLon = cfg.Longitude!.Value;
            var distToOrder = AerialKm(companyLat, companyLon, order.Latitude, order.Longitude);

            var shuffled = couriers.OrderBy(_ => s_rnd.Next()).ToList();
            foreach (var courier in shuffled)
            {
                if (!courier.Active) continue; // prefer active couriers only
                if (courier.PersonalMaxDeliveryDistance.HasValue && distToOrder > courier.PersonalMaxDeliveryDistance.Value) continue;
                if (cfg.MaxGeneralDeliveryDistanceKm.HasValue && distToOrder > cfg.MaxGeneralDeliveryDistanceKm.Value) continue;

                // estimate a duration for this courier (minutes) using simple speed heuristics:
                var speedKmh = courier.DeliveryType switch
                {
                    DeliveryTypes.Car => cfg.AvgCarSpeedKmh,
                    DeliveryTypes.Motorcycle => cfg.AvgMotorcycleSpeedKmh,
                    DeliveryTypes.Bicycle => cfg.AvgBicycleSpeedKmh,
                    DeliveryTypes.OnFoot => cfg.AvgWalkingSpeedKmh,
                    _ => cfg.AvgCarSpeedKmh
                };
                // naive travel time (minutes) = (distance / speed) * 60, plus handling time 10..20
                var travelMin = speedKmh > 0 ? (distToOrder / speedKmh) * 60.0 : 30.0;
                var handling = 10 + s_rnd.Next(0, 21);
                var estimatedDuration = TimeSpan.FromMinutes(Math.Max(5.0, travelMin + handling));

                var candidateStart = desiredStart;
                var candidateEnd = desiredStart.Add(estimatedDuration);

                // check overlap
                var schedule = courierSchedules[courier.Id];
                var overlaps = schedule.Any(slot =>
                    (slot.End == null && slot.Start <= candidateEnd) ||
                    (slot.End != null && slot.Start < candidateEnd && candidateStart < slot.End.Value)
                );
                if (overlaps) continue;

                // found candidate
                return courier;
            }

            return null;
        }

        // helper: persist delivery and register schedule
        void PersistDelivery(Order order, Courier courier, DateTime start, DeliveryEndTypes? endType, DateTime? endTime, double? actualDistanceKm)
        {
            var d = new Delivery(
                Id: 0, // DAL generates
                OrderId: order.Id,
                CourierId: courier.Id,
                DeliveryType: courier.DeliveryType,
                DeliveryStartTime: start,
                ActualDistance: actualDistanceKm,
                DeliveryEndType: endType,
                DeliveryEndTime: endTime
            );
            deliveryDal.Create(d);

            // update schedule
            courierSchedules[courier.Id].Add((start, endTime));
        }

        // 1) In-progress deliveries (no end time)
        foreach (var order in inProgressOrders)
        {
            // desired start: some time after order open but before clock
            var desiredStart = order.OrderOpenTime.AddMinutes(s_rnd.Next(5, 60 * 6));
            if (desiredStart > cfg.Clock) desiredStart = cfg.Clock.AddMinutes(-s_rnd.Next(1, 120));

            var courier = FindAvailableCourier(order, desiredStart);
            if (courier == null) continue; // leave order open if no courier available

            // calculate aerial distance and estimate actual distance as aerial * factor
            var dist = AerialKm(cfg.Latitude!.Value, cfg.Longitude!.Value, order.Latitude, order.Longitude);
            var actual = Math.Round(dist * (1.05 + s_rnd.NextDouble() * 0.5), 3);

            PersistDelivery(order, courier, desiredStart, endType: null, endTime: null, actualDistanceKm: actual);
        }

        // 2) Closed deliveries — use explicit end-type distribution
        var closedEndTypeList = new List<DeliveryEndTypes>();
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.Delivered, Closed_Delivered));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.Failed, Closed_Failed));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.Cancelled, Closed_Cancelled));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.CustomerRefused, Closed_CustomerRefused));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.RecipientNotFound, Closed_RecipientNotFound));
        // shuffle end types to distribute across closed orders
        closedEndTypeList = closedEndTypeList.OrderBy(_ => s_rnd.Next()).ToList();

        for (int i = 0; i < closedOrders.Count; i++)
        {
            var order = closedOrders[i];
            var chosenType = closedEndTypeList[i];

            // start after order open, before clock
            var start = order.OrderOpenTime.AddMinutes(s_rnd.Next(10, 60 * 24));
            if (start > cfg.Clock) start = cfg.Clock.AddMinutes(-s_rnd.Next(1, 180));

            var courier = FindAvailableCourier(order, start);
            if (courier == null) continue;

            // choose duration
            var duration = TimeSpan.FromMinutes(10 + s_rnd.Next(0, 61));
            var endTime = start.Add(duration);

            var dist = AerialKm(cfg.Latitude!.Value, cfg.Longitude!.Value, order.Latitude, order.Longitude);
            var actual = Math.Round(dist * (1.05 + s_rnd.NextDouble() * 0.5), 3);

            PersistDelivery(order, courier, start, chosenType, endTime, actual);

            // For some CustomerRefused / RecipientNotFound we optionally create a reopened successful delivery
            if ((chosenType == DeliveryEndTypes.CustomerRefused || chosenType == DeliveryEndTypes.RecipientNotFound) && s_rnd.NextDouble() < 0.5)
            {
                var reopenedStart = endTime.AddMinutes(30 + s_rnd.Next(0, 180));
                var courier2 = FindAvailableCourier(order, reopenedStart);
                if (courier2 != null)
                {
                    var reopenedDuration = TimeSpan.FromMinutes(10 + s_rnd.Next(0, 61));
                    var reopenedEnd = reopenedStart.Add(reopenedDuration);
                    var actual2 = Math.Round(dist * (1.0 + s_rnd.NextDouble() * 0.5), 3);
                    PersistDelivery(order, courier2, reopenedStart, DeliveryEndTypes.Delivered, reopenedEnd, actual2);
                }
            }
        }

        // 3) Open orders remain without any delivery (explicit)
        // No DAL action needed for open orders here.

        // done: deliveries persisted
    }

    // -----------------------------
    // Small utility helpers
    // -----------------------------

    private static string RandomPhone()
    {
        // Test-ish phone: 050-1234567 style
        var prefixChoices = new[] { "050", "052", "054", "058" };
        var prefix = prefixChoices[s_rnd.Next(prefixChoices.Length)];
        var num = s_rnd.Next(1000000, 9999999);
        return $"{prefix}-{num}";
    }

    private static string SanitizeEmailLocalPart(string fullName)
    {
        // create a simple local part from a name: "First.Last" -> "first.last"
        var p = fullName.ToLowerInvariant().Replace(" ", ".").Replace("-", "").Replace("'", "");
        return p;
    }
}

