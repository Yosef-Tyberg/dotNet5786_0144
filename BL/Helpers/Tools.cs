// Generated by gemini, prompt in readme under stage 4

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using BO;
using DO;
using System.Collections.Concurrent;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;


namespace Helpers;

/// <summary>
/// Utility helper methods for the Business Layer.
/// Provides exception wrapping, conversion utilities, and reflection-based string formatting for DAL and BO operations.
/// </summary>
internal static class Tools
{
    private static readonly HttpClient s_httpClient = new();
    private static readonly ConcurrentDictionary<string, (double, double)> s_coordinateCache = new();
    private static readonly ConcurrentDictionary<string, double> s_routeDistanceCache = new();

    private static DalApi.IDal s_dal = DalApi.Factory.Get;

    //to be called in reset to clear the static caches
    public static void ClearCaches()
    {
        s_coordinateCache.Clear();
        s_routeDistanceCache.Clear();
    }
    /// <summary>
    /// Populates the coordinate cache for testing purposes.
    /// </summary>
    //populate cache for testing purposes
    public static void SeedCoordinateCache()
    {
        // These matches the strings used in Initialization.cs and your Unit Tests
        s_coordinateCache.TryAdd("Ben Yehuda Street, Jerusalem", (31.781500, 35.217600));
        s_coordinateCache.TryAdd("Jaffa Road, Jerusalem", (31.784637, 35.215046));
        s_coordinateCache.TryAdd("Mahane Yehuda, Jerusalem", (31.784700, 35.207300));
        s_coordinateCache.TryAdd("Emek Refaim - German Colony, Jerusalem", (31.757919, 35.218139));
        s_coordinateCache.TryAdd("Givat Shaul, Jerusalem", (31.787128, 35.190108));
        s_coordinateCache.TryAdd("Hebron Road (central), Jerusalem", (31.766509, 35.225938));
        s_coordinateCache.TryAdd("Ein Kerem (outer), Jerusalem", (31.759164, 35.143000));
        s_coordinateCache.TryAdd("Knesset area, Jerusalem", (31.776670, 35.205280));
        s_coordinateCache.TryAdd("Jaffa Road 2, Jerusalem", (31.784637, 35.215046));
        s_coordinateCache.TryAdd("King George Street 1, Jerusalem", (31.782000, 35.218200));
        s_coordinateCache.TryAdd("Test Far Address", (32.500000, 35.000000)); // Approx Haifa/North
    }
    /// <summary>
    /// Validates a full name, ensuring it is not empty, not too long, contains only valid characters, and consists of at least two words.
    /// </summary>
    /// <param name="name">The full name to validate.</param>
    /// <param name="label">The label for the name field (e.g., "Customer Name").</param>
    #region Validation Methods

    public static string? ValidateFullName(string name, string label)
    {
        if (string.IsNullOrWhiteSpace(name))
            return $"{label} cannot be empty.";

        if (name.Length > 60)
            return $"{label} is too long.";

        if (!Regex.IsMatch(name, @"^[A-Za-zא-ת ]+$"))
            return $"{label} may contain only English or Hebrew letters and spaces.";

        bool hasEnglish = Regex.IsMatch(name, @"[A-Za-z]");
        bool hasHebrew = Regex.IsMatch(name, @"[א-ת]");

        if (hasEnglish && hasHebrew)
            return $"{label} cannot contain both English and Hebrew characters.";

        if (name.Contains("    "))
            return $"{label} cannot contain more than three consecutive spaces.";

        if (!Regex.IsMatch(name, @"^ {0,3}[A-Za-zא-ת]+( {1,3}[A-Za-zא-ת]+)+ {0,3}$"))
            return $"{label} must contain at least two words separated by spaces.";

        return null;
    }

    /// <summary>
    /// Validates a phone number, ensuring it is not empty and consists of exactly 10 digits starting with 0.
    /// </summary>
    /// <param name="phone">The phone number to validate.</param>
    /// <param name="label">The label for the phone number field (e.g., "Phone Number").</param>
    public static string? ValidatePhoneNumber(string phone, string label)
    {
        if (string.IsNullOrWhiteSpace(phone))
            return $"{label} cannot be empty.";

        if (!Regex.IsMatch(phone, @"^0\d{9}$"))
            return $"{label} must be exactly 10 digits and start with 0.";

        return null;
    }

    /// <summary>
    /// Validates an email address, ensuring it is not empty and matches a valid email format.
    /// </summary>
    /// <param name="email">The email address to validate.</param>
    /// <param name="label">The label for the email field (e.g., "Email Address").</param>
    public static string? ValidateEmail(string email, string label)
    {
        if (string.IsNullOrWhiteSpace(email))
            return $"{label} cannot be empty.";

        if (!Regex.IsMatch(email, @"^[^@\s]+@[^@\s]+\.[^@\s]+$"))
            return $"{label} '{email}' is not a valid format.";

        return null;
    }

    #endregion

    #region Exception Conversion Methods

    /// <summary>
    /// Converts a DAL exception to an appropriate BO exception, preserving the original exception as inner exception.
    /// </summary>
    /// <param name="exception">The DAL exception to convert.</param>
    /// <param name="operationName">Description of the operation for error messaging.</param>
    /// <returns>An appropriate BO exception.</returns>
    internal static Exception ConvertDalException(Exception exception)
    {
        return exception switch
        {
            DalDoesNotExistException ex => new BlDoesNotExistException($"{ex.Message}", ex),
            DalAlreadyExistsException ex => new BlAlreadyExistsException($"{ex.Message}", ex),
            DalInvalidInputException ex => new BlInvalidInputException($"{ex.Message}", ex),
            _ => exception
        };
    }

    #endregion Exception Conversion Methods

    #region String Formatting Methods

    /// <summary>
    /// Generic extension method that generates a string representation of any object using reflection.
    /// Traverses all public properties and includes nested BO entities and collections.
    /// </summary>
    /// <typeparam name="T">The type of the object to convert to string.</typeparam>
    /// <param name="obj">The object to convert to string.</param>
    /// <returns>A formatted string representation of the object and its properties.</returns>
    public static string ToStringProperty<T>(this T obj)
    {
        if (obj == null)
            return "null";

        StringBuilder sb = new StringBuilder();
        Type objType = obj.GetType();

        // Start with class name
        sb.AppendLine($"{objType.Name}:");
        sb.AppendLine("{");

        // Retrieve all public properties and filter out indexers and write-only properties
        PropertyInfo[] properties = objType.GetProperties(BindingFlags.Public | BindingFlags.Instance);

        var validProperties = from prop in properties
                              where prop.GetGetMethod() != null && prop.GetIndexParameters().Length == 0
                              select prop;

        // Use LINQ Aggregate to build property lines instead of foreach
        var propertyLines = from prop in validProperties
                            select FormatPropertyLine(prop, obj);

        string allPropertyLines = string.Join(Environment.NewLine, propertyLines);
        if (!string.IsNullOrEmpty(allPropertyLines))
        {
            sb.Append(allPropertyLines).AppendLine();
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    /// <summary>
    /// Formats a single property line for display, handling exceptions gracefully.
    /// </summary>
    /// <param name="prop">The property to format.</param>
    /// <param name="obj">The object containing the property.</param>
    /// <returns>A formatted property line.</returns>
    private static string FormatPropertyLine(PropertyInfo prop, object obj)
    {
        try
        {
            object? value = prop.GetValue(obj);
            string propertyValue = FormatPropertyValue(value);
            return $"  {prop.Name}: {propertyValue}";
        }
        catch
        {
            return $"  {prop.Name}: [Error reading property]";
        }
    }

    /// <summary>
    /// Formats a property value for display, handling null, collection, and nested object cases.
    /// </summary>
    /// <param name="value">The property value to format.</param>
    /// <returns>A formatted string representation of the value.</returns>
    private static string FormatPropertyValue(object? value)
    {
        // Handle null values
        if (value == null)
            return "null";

        // Handle string values
        if (value is string str)
            return $"\"{str}\"";

        // Handle Enums
        if (value is Enum)
            return value.ToString();

        // Handle doubles
        if (value is double d)
            return d.ToString("0.##");

        // Handle TimeSpan
        if (value is TimeSpan ts)
            return FormatTimeSpan(ts);

        // Handle collections (List, IEnumerable, etc.)
        if (value is IEnumerable enumerable)
        {
            return FormatCollection(enumerable);
        }

        // Handle BO entities (nested objects)
        if (value.GetType().Namespace == "BO")
        {
            return value.ToString() ?? "null";
        }

        // Handle primitive types and other types
        return value.ToString() ?? "null";
    }

    /// <summary>
    /// Formats a collection/list for display.
    /// </summary>
    /// <param name="enumerable">The collection to format.</param>
    /// <returns>A formatted string representation of the collection.</returns>
    private static string FormatCollection(IEnumerable enumerable)
    {
        var items = new List<string>();
        foreach (var item in enumerable)
        {
            items.Add(FormatPropertyValue(item));
        }
        return $"[{string.Join(", ", items)}]";
    }

    /// <summary>
    /// Formats a TimeSpan value into a human-readable string.
    /// </summary>
    /// <param name="ts">The TimeSpan to format.</param>
    /// <returns>A formatted string representation of the TimeSpan.</returns>
    private static string FormatTimeSpan(TimeSpan ts)
    {
        bool isNegative = ts < TimeSpan.Zero;
        ts = ts.Duration();
        var parts = new List<string>();

        int days = ts.Days;
        if (days >= 365)
        {
            int years = days / 365;
            parts.Add($"{years} year{(years > 1 ? "s" : "")}");
            days %= 365;
        }
        if (days >= 30)
        {
            int months = days / 30;
            parts.Add($"{months} month{(months > 1 ? "s" : "")}");
            days %= 30;
        }
        if (days > 0)
        {
            parts.Add($"{days} day{(days > 1 ? "s" : "")}");
        }

        if (ts.Hours > 0) parts.Add($"{ts.Hours} hour{(ts.Hours > 1 ? "s" : "")}");
        if (ts.Minutes > 0) parts.Add($"{ts.Minutes} minute{(ts.Minutes > 1 ? "s" : "")}");
        if (ts.Seconds > 0) parts.Add($"{ts.Seconds} second{(ts.Seconds > 1 ? "s" : "")}");

        string result = parts.Count > 0 ? string.Join(" ", parts) : "0 seconds";
        return isNegative ? $"- {result}" : result;
    }

    #endregion String Formatting Methods

    #region Calculation Methods

    /// <summary>
    /// Calculates the distance between two geographical points using the Haversine formula.
    /// </summary>
    /// <param name="lat1">Latitude of the first point.</param>
    /// <param name="lon1">Longitude of the first point.</param>
    /// <param name="lat2">Latitude of the second point.</param>
    /// <param name="lon2">Longitude of the second point.</param>
    /// <returns>The distance in kilometers.</returns>
    public static double GetAerialDistance(double lat1, double lon1, double lat2, double lon2)
    {
        const double R = 6371; // Earth's radius in kilometers
        var dLat = ToRadians(lat2 - lat1);
        var dLon = ToRadians(lon2 - lon1);
        var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                Math.Cos(ToRadians(lat1)) * Math.Cos(ToRadians(lat2)) *
                Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
        var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
        return R * c;
    }

    /// <summary>
    /// Converts an angle from degrees to radians.
    /// </summary>
    /// <param name="angle">The angle in degrees.</param>
    /// <returns>The angle in radians.</returns>
    private static double ToRadians(double angle)
    {
        return Math.PI * angle / 180.0;
    }

    /// <summary>
    /// gets the coordinate of a given address
    /// </summary>
    /// <param name="address"></param>
    /// <returns>a tuple of two doubles, the first is that latitude and the second is the logitude</returns>
    /// <exception cref="BlInvalidInputException"></exception>
    public static (double, double) GetCoordinates(string address)
    {
        if (string.IsNullOrWhiteSpace(address))
        {
            throw new BlInvalidAddressException("address cannot be null or empty");
        }
            
        if (s_coordinateCache.TryGetValue(address, out var coordinates))
        {
            return coordinates;
        }

        try
        {
            // The Nominatim API endpoint for searching a structured query
            string url = $"https://nominatim.openstreetmap.org/search?q={Uri.EscapeDataString(address)}&format=json&limit=1";
            s_httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("My-C#-App");
            string json = s_httpClient.GetStringAsync(url).Result;

            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            var results = JsonSerializer.Deserialize<List<NominatimResult>>(json, options);

            if (results?.Count > 0)
            {
                var bestResult = results[0];
                var newCoordinates = (double.Parse(bestResult.Lat), double.Parse(bestResult.Lon));
                s_coordinateCache.TryAdd(address, newCoordinates);
                return newCoordinates;
            }
        }
        catch (Exception ex)
        {
            throw new BlInvalidAddressException("Error getting coordinates", ex);
        }
        throw new BlInvalidAddressException("address not found");
    }

    /// <summary>
    /// gets the driving distance between two locations
    /// </summary>
    /// <param name="lat1"></param>
    /// <param name="lon1"></param>
    /// <param name="lat2"></param>
    /// <param name="lon2"></param>
    /// <returns>the driving distance in km</returns>
    /// <exception cref="BlInvalidInputException"></exception>
    public static double GetDrivingDistance(double lat1, double lon1, double lat2, double lon2)
    {
        return GetRouteDistance(lat1, lon1, lat2, lon2, "driving");
    }

    /// <summary>
    /// gets the walking distance between two locations
    /// </summary>
    /// <param name="lat1"></param>
    /// <param name="lon1"></param>
    /// <param name="lat2"></param>
    /// <param name="lon2"></param>
    /// <returns>the walking distance in km</returns>
    /// <exception cref="BlInvalidInputException"></exception>
    public static double GetWalkingDistance(double lat1, double lon1, double lat2, double lon2)
    {
        return GetRouteDistance(lat1, lon1, lat2, lon2, "foot");
    }

    private static double GetRouteDistance(double lat1, double lon1, double lat2, double lon2, string profile)
    {
        string cacheKey = $"{lat1},{lon1};{lat2},{lon2};{profile}";
        if (s_routeDistanceCache.TryGetValue(cacheKey, out double distance))
        {
            return distance;
        }

        try
        {
            string url = $"http://router.project-osrm.org/route/v1/{profile}/{lon1},{lat1};{lon2},{lat2}?overview=false";
            s_httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("My-C#-App");
            string json = s_httpClient.GetStringAsync(url).Result;

            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            var result = JsonSerializer.Deserialize<OsrmResponse>(json, options);

            if (result?.Routes?.Count > 0)
            {
                double newDistance = result.Routes[0].Distance / 1000; // Convert meters to kilometers
                s_routeDistanceCache.TryAdd(cacheKey, newDistance);
                return newDistance;
            }
        }
        catch (Exception ex)
        {
            throw new BlInvalidInputException("Error getting distance", ex);
        }
        throw new BlInvalidInputException("could not find a route");
    }
    #endregion
    /// <summary>
    /// Calculates the expected delivery time for an order.
    /// </summary>
    /// <param name="deliveryType">The type of delivery.</param>
    /// <param name="order">The order to calculate the delivery time for.</param>
    /// <param name="config">The configuration containing delivery settings.</param>
    /// <param name="activeDelivery">Optional: The active delivery associated with the order.</param>
    /// <returns>The calculated expected delivery time.</returns>

    #region Schedule Methods

    /// <summary>
    /// Calculates the expected delivery time for an order/delivery. if now>estimate returns now. 
    /// </summary>
    /// <param name="deliveryType">The delivery type.</param>
    /// <param name="order">The associated order.</param>
    /// <returns>The calculated expected delivery time.</returns>
    /// <exception cref="BO.BlMissingPropertyException">Thrown when calculation fails.</exception>
    internal static DateTime CalculateExpectedDeliveryTime(DO.DeliveryTypes deliveryType, DO.Order order, DalApi.IConfig config, DO.Delivery? activeDelivery = null)
    {
        // Determine the start time: if an active delivery exists for the order, use its DeliveryStartTime; otherwise, use AdminManager.Now 
        DateTime startTime = activeDelivery?.DeliveryStartTime ?? AdminManager.Now;

        var (distance, speed) = GetDistanceAndSpeed(deliveryType, order, config);

        if (speed >= 1)
        {
            var estimatedHours = distance / speed;
            var estimate = startTime.AddHours(estimatedHours);
            //if its already later than expected time (affects open deliveries)
            if (estimate < AdminManager.Now) 
                return AdminManager.Now;
            return estimate;
        }

        throw new BO.BlMissingPropertyException("Average speed must be >= 1 km/h");
    }

    private static (double distance, double speed) GetDistanceAndSpeed(DO.DeliveryTypes deliveryType, DO.Order order, DalApi.IConfig config)
    {
        double distance;
        double speed;
        switch (deliveryType)
        {
            case DO.DeliveryTypes.Car:
                distance = Tools.GetDrivingDistance((double)(config.Latitude ?? 0), (double)(config.Longitude ?? 0), order.Latitude, order.Longitude);
                speed = config.AvgCarSpeedKmh;
                break;
            case DO.DeliveryTypes.Motorcycle:
                distance = Tools.GetDrivingDistance((double)(config.Latitude ?? 0), (double)(config.Longitude ?? 0), order.Latitude, order.Longitude);
                speed = config.AvgMotorcycleSpeedKmh;
                break;
            case DO.DeliveryTypes.Bicycle:
                distance = Tools.GetWalkingDistance((double)(config.Latitude ?? 0), (double)(config.Longitude ?? 0), order.Latitude, order.Longitude);
                speed = config.AvgBicycleSpeedKmh;
                break;
            case DO.DeliveryTypes.OnFoot:
                distance = Tools.GetWalkingDistance((double)(config.Latitude ?? 0), (double)(config.Longitude ?? 0), order.Latitude, order.Longitude);
                speed = config.AvgWalkingSpeedKmh;
                break;
            default:
                throw new BO.BlMissingPropertyException($"Could not calculate properties for unrecognized delivery type: {deliveryType}");
        }
        return (distance, speed);
    }

    internal static BO.ScheduleStatus DetermineScheduleStatus(DO.Order order, DalApi.IConfig config, DO.Delivery? activeDelivery = null)
    {
        var deliveryType = GetFastestType(config);
        
        if (activeDelivery != null)
        {
            deliveryType = activeDelivery.DeliveryType;
        }
        
        var arrival = CalculateExpectedDeliveryTime(deliveryType, order, config, activeDelivery);  
        var deadline = order.OrderOpenTime.Add(config.MaxDeliveryTimeSpan);
        //late only if current time is after deadline
        if (AdminManager.Now > deadline)
            return BO.ScheduleStatus.Late;
        //at risk if the time left until deadline is less than risk range (including negative - expected arrival is late)
        if ((deadline - arrival) < config.RiskRange)
            return BO.ScheduleStatus.AtRisk;

        return BO.ScheduleStatus.OnTime;
    }

    /// <summary>
    /// Determines the fastest delivery type based on the provided configuration.
    /// </summary>
    /// <param name="config">The configuration containing delivery speeds.</param>
    /// <returns>The fastest delivery type.</returns>
    /// <exception cref="InvalidOperationException">Thrown when no delivery types are configured.</exception>

    internal static DO.DeliveryTypes GetFastestType(DalApi.IConfig config)
    {
        // Explicitly mapping DO types to speeds from the BO config
        var speeds = new Dictionary<DO.DeliveryTypes, double>
    {
        { DO.DeliveryTypes.Car, config.AvgCarSpeedKmh },
        { DO.DeliveryTypes.Motorcycle, config.AvgMotorcycleSpeedKmh },
        { DO.DeliveryTypes.Bicycle, config.AvgBicycleSpeedKmh },
        { DO.DeliveryTypes.OnFoot, config.AvgWalkingSpeedKmh }
    };

        // Ordering by speed ensures we don't crash if a key is missing 
        // or if the dictionary is somehow empty.
        var fastest = speeds.OrderByDescending(x => x.Value).FirstOrDefault();

        // Fallback to Motorcycle if something goes wrong to prevent crash
        return fastest.Key != default ? fastest.Key : DO.DeliveryTypes.Motorcycle;
    }

    #endregion

    #region Helper Classes for JSON Deserialization

    private class NominatimResult
    {
        public string Lat { get; set; } = string.Empty;
        public string Lon { get; set; } = string.Empty;
    }

    private class OsrmResponse
    {
        public List<OsrmRoute> Routes { get; set; } = new();
    }

    private class OsrmRoute
    {
        public double Distance { get; set; }
    }

    #endregion
}
