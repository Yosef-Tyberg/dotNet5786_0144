
using DalApi;
using DO;

namespace DalTest;

/*stage 1 of this file was generated by chatgpt using the following prompts:
 * 1)
 * now, based on the classes i've given you, i would like you to create a test class for this project. 
 * first, within DalTest, I want to create an initialization class which will initialize the database with legal values. 
 * Data must be valid, legal, and logically related, maintaining referential integrity.
 * I then pasted in the data requirements from the document we were given.
 * 2)
 * to be clear there are two files in total. the first, called Initialization, contains the methods to populate 
 * the database + all helper methods needed for that task. finally it contains a method named Do which contains 
 * all the population methods - so when called it will populate the database fully. 
 * the second file is called Program and contains a Main function, which starts off by calling Initialization.Do 
 * for now i'd like to focus on the initialization file. first of all, there is not yet a factory method, 
 * nor do i wish to implement one at this time. instead, the class should contain the fields: private static ICourier? s_dalCourier; 
 * private static IDelivery? s_dalDelivery; private static IOrder? s_dalOrder; private static IConfig? s_dalConfig; 
 * and use those to access the CRUD and config implemented methods. 
 * next, I would like the names of the couriers to be actual names, not just courierI. 
 * I would like to ensure the numbers regarding the entities are accurate, so instead of using 
 * weighted probabilities to get the right distribution, please make the distribution explicit.
 * 
 * stage two modifications were made with the chatgptprompts:
 * 1) 
 * I have made some changes to the class structure. now all implementations are accessed more centrally in the class: (pasted DalList)
 * this necessitates changes to the initialization class as well.
 * I have already created the appropriate fields, with stage2 commented after them, 
 * while the previous fields have been commented out with the comment stage1 preceding them. 
 * I would like you to modify the class to use the correct names. here is the current class for comparison: (pasted slightly modified
 * Initialization class)
 * 2)
 * I would like to modify the exceptions used. instead of calling any of the currently used exceptions, 
 * only my exceptions defined in Exceptions.cs should be used.
 */

/// <summary>
/// Database initialization helper that populates the DAL with valid, consistent data..
/// </summary>
public static class Initialization
{
    // stage2 - central DAL
    private static IDal? s_dal; // stage2

    // deterministic random for reproducible test data
    private static readonly Random s_rnd = new Random(123456);

    // explicit counts / distributions (as requested)
    private const int CouriersCount = 20;
    private const int CouriersActiveCount = 17;
    private const int CouriersInactiveCount = CouriersCount - CouriersActiveCount; // 3

    private const int OrdersCount = 50;
    private const int OrdersOpenCount = 20;
    private const int OrdersInProgressCount = 10;
    private const int OrdersClosedCount = 20; // totals 50

    // explicit closed-end-type distribution (sum must equal OrdersClosedCount)
    private const int Closed_Delivered = 14;
    private const int Closed_Failed = 1;
    private const int Closed_Cancelled = 1;
    private const int Closed_CustomerRefused = 2;
    private const int Closed_RecipientNotFound = 2;

    //legal ID limits
    private const int minId = 200000000;
    private const int maxId = 999999999;

    // small test address model
    private record TestAddress(string Label, double Lat, double Lon);

    /// <summary>
    /// Populates the DAL fully (config, couriers, orders, deliveries).
    /// </summary>
    public static void Do(IDal dal)
    {
        s_dal = dal ?? throw new NullReferenceException("DAL object can not be null!"); // stage 2

        Console.WriteLine("Reset Configuration values and List values...");
        // Reset the DB (ResetDB handles clearing lists + s_dal.Config.Reset())
        s_dal.ResetDB();

        // 1. initialize config (sets DO.s_dal.Config values)
        InitializeConfig();

        // 2. Prepare a short list of real-ish addresses (labels + coordinates)
        var addresses = PrepareAddresses();

        // 3. Create Couriers (explicit distribution) — pass the central dal
        var createdCouriers = CreateCouriers(s_dal, CouriersCount, CouriersActiveCount);

        // 4. Create Orders (pass Id = 0 to allow DAL auto-generation). 50 orders.
        var createdOrders = CreateOrders(s_dal, addresses, OrdersCount, s_dal.Config.Clock);

        // 5. Create Deliveries (assign courier->order respecting distances and no overlapping)
        CreateDeliveries(s_dal, createdCouriers, createdOrders);
    }

    // -----------------------------
    // Internal helpers
    // -----------------------------

    /// <summary>
    /// Initialize static s_dal.Config values (DO.s_dal.Config).
    /// </summary>
    private static void InitializeConfig()
    {
        // Example company coordinates - change as appropriate for your tests
        s_dal.Config.CompanyFullAddress = "Downtown (test) - company HQ";
        s_dal.Config.Latitude = 31.771959;
        s_dal.Config.Longitude = 35.217018;

        // reasonable urban speed assumptions
        s_dal.Config.AvgCarSpeedKmh = 40.0;
        s_dal.Config.AvgMotorcycleSpeedKmh = 35.0;
        s_dal.Config.AvgBicycleSpeedKmh = 15.0;
        s_dal.Config.AvgWalkingSpeedKmh = 5.0;

        // Delivery limits & thresholds
        s_dal.Config.MaxGeneralDeliveryDistanceKm = 10.0; // global max radius
        s_dal.Config.MaxDeliveryTimeSpan = TimeSpan.FromHours(2);
        s_dal.Config.RiskRange = TimeSpan.FromMinutes(10);
        s_dal.Config.InactivityRange = TimeSpan.FromMinutes(30);

        // set test clock to now (or any fixed time)
        s_dal.Config.Clock = DateTime.Now;
    }

    /// <summary>
    /// Prepare a short fixed list of addresses near the company location.
    /// </summary>
    private static List<TestAddress> PrepareAddresses()
    {
        return new List<TestAddress>
            {
                new TestAddress("Ben Yehuda Street", 31.781500, 35.217600),
                new TestAddress("Jaffa Road", 31.784637, 35.215046),
                new TestAddress("Mahane Yehuda", 31.784700, 35.207300),
                new TestAddress("Emek Refaim - German Colony", 31.757919, 35.218139),
                new TestAddress("Givat Shaul", 31.787128, 35.190108),
                new TestAddress("Hebron Road (central)", 31.766509, 35.225938),
                new TestAddress("Ein Kerem (outer)", 31.759164, 35.143000),
                new TestAddress("Knesset area", 31.776670, 35.205280)
            };
    }

    /// <summary>
    /// Create a fixed set of couriers. Distribution is explicit.
    /// Uses s_dal.Courier internally.
    /// </summary>
    private static List<Courier> CreateCouriers(IDal s_dal, int courierCount, int activeCount)
    {
        var courierDal = s_dal.Courier;
        var output = new List<Courier>(courierCount);

        // explicit real-ish names list (enough unique names)
        var names = new[]
        {
                "Ariel Cohen", "Maya Levi", "Noam Shalev", "Lior Kaplan", "Yael Barak",
                "Ethan Mizrahi", "Nadav Rosen", "Shira Gold", "Omer Katz", "Talia Aviv",
                "Daniel Harel", "Roni Peretz", "Galit Stern", "Itai Levy", "Rivka Eitan",
                "Avi Ben-David", "Hannah Azulay", "Eitan Strauss", "Lina Doron", "Yonatan Amir"
            };

        // Uniformly assign delivery types: ensure as-even-as-possible distribution
        var types = Enum.GetValues(typeof(DeliveryTypes)).Cast<DeliveryTypes>().ToArray();
        var assignedTypes = new List<DeliveryTypes>();
        for (int i = 0; i < courierCount; i++)
            assignedTypes.Add(types[i % types.Length]); // cycles to produce even distribution

        // shuffle assigned types slightly to distribute across indices
        assignedTypes = assignedTypes.OrderBy(_ => s_rnd.Next()).ToList();

        // company global max used for per-courier personal max selection
        var globalMax = s_dal.Config.MaxGeneralDeliveryDistanceKm ?? 10.0;

        int minID = minId;
        for (int i = 0; i < courierCount; i++)
        {
            //to prevent id collisions cheaply, we choose ids in increasing order. min increase is 1. max is (remaining range)/(remaining couriers)
            //to avoid running out of space
            int id = minID + s_rnd.Next(1, (maxId - minID) / (courierCount - i));
            minID = id;

            var fullName = names[i % names.Length];

            // personal max: choose randomly but <= global max. Some couriers may leave it null.
            double? personalMax = null;
            if (s_rnd.NextDouble() < 0.8) // 80% of couriers have a personal max
            {
                var val = 1.0 + s_rnd.NextDouble() * Math.Max(0.0, globalMax - 1.0);
                personalMax = Math.Round(val, 2);
            }

            // employment start earlier than the system clock
            var start = s_dal.Config.Clock.AddDays(-s_rnd.Next(1, 365 * 3)).AddMinutes(-s_rnd.Next(0, 60 * 24));

            var courier = new Courier(
                Id: id,
                FullName: fullName,
                MobilePhone: RandomPhone(),
                Email: $"{SanitizeEmailLocalPart(fullName)}@example.test",
                Password: "pwd", // simple password for test data
                Active: true, // temporarily set true; will mark some inactive explicitly below
                DeliveryType: assignedTypes[i],
                EmploymentStartTime: start,
                PersonalMaxDeliveryDistance: personalMax
            );

            courierDal.Create(courier);
            output.Add(courier);
        }

        // mark explicit number inactive
        var toMarkInactive = output.OrderBy(_ => s_rnd.Next()).Take(CouriersInactiveCount).ToList();
        foreach (var c in toMarkInactive)
        {
            var updated = c with { Active = false, EmploymentStartTime = c.EmploymentStartTime.AddYears(-1) };
            courierDal.Update(updated);
            var index = output.FindIndex(x => x.Id == c.Id);
            if (index >= 0) output[index] = updated;
        }

        // enforce exact active count if necessary
        var finalActive = output.Count(c => c.Active);
        if (finalActive != activeCount)
        {
            if (finalActive > activeCount)
            {
                var toDeactivate = output.Where(c => c.Active).OrderByDescending(c => c.EmploymentStartTime).Take(finalActive - activeCount).ToList();
                foreach (var c in toDeactivate)
                {
                    var upd = c with { Active = false };
                    courierDal.Update(upd);
                    var idx = output.FindIndex(x => x.Id == c.Id);
                    if (idx >= 0) output[idx] = upd;
                }
            }
            else if (finalActive < activeCount)
            {
                var toActivate = output.Where(c => !c.Active).OrderBy(c => c.EmploymentStartTime).Take(activeCount - finalActive).ToList();
                foreach (var c in toActivate)
                {
                    var upd = c with { Active = true };
                    courierDal.Update(upd);
                    var idx = output.FindIndex(x => x.Id == c.Id);
                    if (idx >= 0) output[idx] = upd;
                }
            }
        }

        return output;
    }

    /// <summary>
    /// Create orders (Id = 0 so DAL assigns IDs). Returns the list of orders as read back from DAL (with assigned Ids).
    /// Uses s_dal.Order internally.
    /// </summary>
    private static List<Order> CreateOrders(IDal s_dal, List<TestAddress> addresses, int totalCount, DateTime clock)
    {
        var orderDal = s_dal.Order;
        var created = new List<Order>(totalCount);
        var orderTypes = Enum.GetValues(typeof(OrderTypes)).Cast<OrderTypes>().ToArray();

        for (int i = 0; i < totalCount; i++)
        {
            var addr = addresses[s_rnd.Next(addresses.Count)];

            var otype = orderTypes[s_rnd.Next(orderTypes.Length)];
            var verbal = otype == OrderTypes.Pizza ? "Pizza order" : "Falafel order";

            var openTime = clock.AddMinutes(-s_rnd.Next(1, 60 * 24 * 14)); // opened sometime within last 14 days

            var order = new Order(
                Id: 0, // DAL assigns
                OrderType: otype,
                VerbalDescription: $"{verbal} #{i + 1}",
                FullOrderAccess: Guid.NewGuid().ToString("N"),
                Latitude: addr.Lat,
                Longitude: addr.Lon,
                CustomerFullName: $"Customer {i + 1}",
                CustomerMobile: RandomPhone(),
                Volume: Math.Round(0.1 + s_rnd.NextDouble() * 3.0, 3),
                Weight: Math.Round(0.1 + s_rnd.NextDouble() * 10.0, 3),
                Fragile: s_rnd.NextDouble() < 0.15,
                Height: Math.Round(5 + s_rnd.NextDouble() * 50, 2),
                Width: Math.Round(5 + s_rnd.NextDouble() * 50, 2),
                OrderOpenTime: openTime
            );

            orderDal.Create(order);
            created.Add(order); // these instances may not have real IDs; we'll read them back below
        }

        // Read back all orders from DAL to obtain real assigned IDs and return them sorted by open time
        var ordersFromDal = orderDal.ReadAll().OrderBy(o => o.OrderOpenTime).ToList();
        return ordersFromDal;
    }

    /// <summary>
    /// Creates deliveries based on explicit partitioning of orders.
    /// Uses s_dal.Delivery / s_dal.Courier / s_dal.Order internally.
    /// </summary>
    private static void CreateDeliveries(IDal s_dal, List<Courier> createdCouriers, List<Order> ordersFromDal)
    {
        var deliveryDal = s_dal.Delivery;
        var courierDal = s_dal.Courier;
        var orderDal = s_dal.Order;

        // Defensive reads from DAL (ReadAll returns a safe copy)
        var couriers = courierDal.ReadAll();
        var orders = new List<Order>(ordersFromDal); // local mutable copy

        if (orders.Count < OrdersCount)
            throw new DalInvalidInputException("Not enough orders in DAL to partition as requested.");

        var openOrders = orders.Take(OrdersOpenCount).ToList();
        var inProgressOrders = orders.Skip(OrdersOpenCount).Take(OrdersInProgressCount).ToList();
        var closedOrders = orders.Skip(OrdersOpenCount + OrdersInProgressCount).Take(OrdersClosedCount).ToList();

        // track per-courier schedule to prevent overlaps: list of (start,end)
        var courierSchedules = couriers.ToDictionary(c => c.Id, c => new List<(DateTime Start, DateTime? End)>());

        // helper: haversine aerial distance
        static double AerialKm(double lat1, double lon1, double lat2, double lon2)
        {
            const double R = 6371.0;
            double d2r(double deg) => deg * Math.PI / 180.0;
            var dLat = d2r(lat2 - lat1);
            var dLon = d2r(lon2 - lon1);
            var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2)
                    + Math.Cos(d2r(lat1)) * Math.Cos(d2r(lat2))
                    * Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
            var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            return R * c;
        }

        // helper: find an available courier for an order at desiredStart respecting distances & no overlaps
        Courier? FindAvailableCourier(Order order, DateTime desiredStart)
        {
            var companyLat = s_dal.Config.Latitude!.Value;
            var companyLon = s_dal.Config.Longitude!.Value;
            var distToOrder = AerialKm(companyLat, companyLon, order.Latitude, order.Longitude);

            var shuffled = couriers.OrderBy(_ => s_rnd.Next()).ToList();
            foreach (var courier in shuffled)
            {
                if (!courier.Active) continue; // prefer active couriers only
                if (courier.PersonalMaxDeliveryDistance.HasValue && distToOrder > courier.PersonalMaxDeliveryDistance.Value) continue;
                if (s_dal.Config.MaxGeneralDeliveryDistanceKm.HasValue && distToOrder > s_dal.Config.MaxGeneralDeliveryDistanceKm.Value) continue;

                // estimate a duration for this courier (minutes) using simple speed heuristics:
                var speedKmh = courier.DeliveryType switch
                {
                    DeliveryTypes.Car => s_dal.Config.AvgCarSpeedKmh,
                    DeliveryTypes.Motorcycle => s_dal.Config.AvgMotorcycleSpeedKmh,
                    DeliveryTypes.Bicycle => s_dal.Config.AvgBicycleSpeedKmh,
                    DeliveryTypes.OnFoot => s_dal.Config.AvgWalkingSpeedKmh,
                    _ => s_dal.Config.AvgCarSpeedKmh
                };
                var travelMin = speedKmh > 0 ? (distToOrder / speedKmh) * 60.0 : 30.0;
                var handling = 10 + s_rnd.Next(0, 21);
                var estimatedDuration = TimeSpan.FromMinutes(Math.Max(5.0, travelMin + handling));

                var candidateStart = desiredStart;
                var candidateEnd = desiredStart.Add(estimatedDuration);

                // check overlap
                var schedule = courierSchedules[courier.Id];
                var overlaps = schedule.Any(slot =>
                    (slot.End == null && slot.Start <= candidateEnd) ||
                    (slot.End != null && slot.Start < candidateEnd && candidateStart < slot.End.Value)
                );
                if (overlaps) continue;

                // found candidate
                return courier;
            }

            return null;
        }

        // helper: persist delivery and register schedule
        void PersistDelivery(Order order, Courier courier, DateTime start, DeliveryEndTypes? endType, DateTime? endTime, double? actualDistanceKm)
        {
            var d = new Delivery(
                Id: 0, // DAL generates
                OrderId: order.Id,
                CourierId: courier.Id,
                DeliveryType: courier.DeliveryType,
                DeliveryStartTime: start,
                ActualDistance: actualDistanceKm,
                DeliveryEndType: endType,
                DeliveryEndTime: endTime
            );
            deliveryDal.Create(d);

            // update schedule
            courierSchedules[courier.Id].Add((start, endTime));
        }

        // 1) In-progress deliveries (no end time)
        foreach (var order in inProgressOrders)
        {
            var desiredStart = order.OrderOpenTime.AddMinutes(s_rnd.Next(5, 60 * 6));
            if (desiredStart > s_dal.Config.Clock) desiredStart = s_dal.Config.Clock.AddMinutes(-s_rnd.Next(1, 120));

            var courier = FindAvailableCourier(order, desiredStart);
            if (courier == null) continue; // leave order open if no courier available

            var dist = AerialKm(s_dal.Config.Latitude!.Value, s_dal.Config.Longitude!.Value, order.Latitude, order.Longitude);
            var actual = Math.Round(dist * (1.05 + s_rnd.NextDouble() * 0.5), 3);

            PersistDelivery(order, courier, desiredStart, endType: null, endTime: null, actualDistanceKm: actual);
        }

        // 2) Closed deliveries — use explicit end-type distribution
        var closedEndTypeList = new List<DeliveryEndTypes>();
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.Delivered, Closed_Delivered));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.Failed, Closed_Failed));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.Cancelled, Closed_Cancelled));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.CustomerRefused, Closed_CustomerRefused));
        closedEndTypeList.AddRange(Enumerable.Repeat(DeliveryEndTypes.RecipientNotFound, Closed_RecipientNotFound));
        closedEndTypeList = closedEndTypeList.OrderBy(_ => s_rnd.Next()).ToList();

        for (int i = 0; i < closedOrders.Count; i++)
        {
            var order = closedOrders[i];
            var chosenType = closedEndTypeList[i];

            var start = order.OrderOpenTime.AddMinutes(s_rnd.Next(10, 60 * 24));
            if (start > s_dal.Config.Clock) start = s_dal.Config.Clock.AddMinutes(-s_rnd.Next(1, 180));

            var courier = FindAvailableCourier(order, start);
            if (courier == null) continue;

            var duration = TimeSpan.FromMinutes(10 + s_rnd.Next(0, 61));
            var endTime = start.Add(duration);

            var dist = AerialKm(s_dal.Config.Latitude!.Value, s_dal.Config.Longitude!.Value, order.Latitude, order.Longitude);
            var actual = Math.Round(dist * (1.05 + s_rnd.NextDouble() * 0.5), 3);

            PersistDelivery(order, courier, start, chosenType, endTime, actual);

            // simulate reopened cases
            if ((chosenType == DeliveryEndTypes.CustomerRefused || chosenType == DeliveryEndTypes.RecipientNotFound) && s_rnd.NextDouble() < 0.5)
            {
                var reopenedStart = endTime.AddMinutes(30 + s_rnd.Next(0, 180));
                var courier2 = FindAvailableCourier(order, reopenedStart);
                if (courier2 != null)
                {
                    var reopenedDuration = TimeSpan.FromMinutes(10 + s_rnd.Next(0, 61));
                    var reopenedEnd = reopenedStart.Add(reopenedDuration);
                    var actual2 = Math.Round(dist * (1.0 + s_rnd.NextDouble() * 0.5), 3);
                    PersistDelivery(order, courier2, reopenedStart, DeliveryEndTypes.Delivered, reopenedEnd, actual2);
                }
            }
        }

        // 3) Open orders remain without any delivery
    }

    // -----------------------------
    // Small utility helpers
    // -----------------------------

    private static string RandomPhone()
    {
        var prefixChoices = new[] { "050", "052", "054", "058" };
        var prefix = prefixChoices[s_rnd.Next(prefixChoices.Length)];
        var num = s_rnd.Next(1000000, 9999999);
        return $"{prefix}-{num}";
    }

    private static string SanitizeEmailLocalPart(string fullName)
    {
        var p = fullName.ToLowerInvariant().Replace(" ", ".").Replace("-", "").Replace("'", "");
        return p;
    }
}