<!-- Generated by Gemini. Prompt is in the Readme under Stage 5 -->
All DO, DalApi and DalList classes were commented by chatgpt using the following prompt:

I'm working on a project for managing couriers and orders+deliveries for a company.
i have several C# files from it i would like you to comment for me using the same format as the following:

(gave it an example file and all the files to be commented)


# Stage 3:

/*Config and all the entity implementation classes + the data-config file, were generated based on 
 the following prompt to github copilot using claude (due to its length I will paste it in the Readme (and Config), but not every class):
 
Up until now, all implementations have been through the DalList project, 
with data saved in lists in Datasource.cs.
I would now like to create the option to use persistent storage instead, via XML files.
To that end, I’ve created the "xml" folder to store the XML files to be used for persistent storage,
and the DalXml project for the implementation using those files.

The XmlTools class contains methods to help with those implementations.
The data-config XML file is to be used to store all the variables found in the (DalList) Config class.
The other XML files will store lists of the appropriate entities.

Your first task is to implement DalXml.Config.
This class is a mirror of the DalList Config class — it needs getters and setters for all the appropriate variables,
but it must load and save the XML file instead of just storing values in the class.
Make sure to use the methods from XmlTools.

Example (though it uses different entity names):

internal static int NextCourseId
{
    get => XMLTools.GetAndIncreaseConfigIntVal(s_data_config_xml, "NextCourseId");
    private set => XMLTools.SetConfigIntVal(s_data_config_xml, "NextCourseId", value);
}

internal static DateTime Clock
{
    get => XMLTools.GetConfigDateVal(s_data_config_xml, "Clock");
    set => XMLTools.SetConfigDateVal(s_data_config_xml, "Clock", value);
}

Include the ResetConfig method as well.

Your second task is to set up the data-config XML file for all those variables.
Partial example:

xml version="1.0" encoding="utf-8"?>
<config>
  <NextOrderId>1008</NextOrderId>
  <NextDeliveryId>41</NextDeliveryId>
  <MaxRange>41</MaxRange>
</config>

Your third task is to implement the implementation classes in the DalXml project (except ConfigImplementation, which I already completed).
I created the classes, but right now all the methods just throw exceptions.
Each of those methods should do the exact same thing as their counterparts in DalList — 
but load/save from/to the appropriate XML file instead of using Datasource’s lists.
Once again, please use the methods from XmlTools.

There are two options provided by XmlTools.

Option 1: XmlSerializer
Example (different entities):

public void Update(Course item)
{
    List<Course> Courses = XMLTools.LoadListFromXMLSerializer<Course>(Config.s_courses_xml);
    if (Courses.RemoveAll(it => it.Id == item.Id) == 0)
        throw new DalDoesNotExistException($"Course with ID={item.Id} does Not exist");
    Courses.Add(item);
    XMLTools.SaveListToXMLSerializer(Courses, Config.s_courses_xml);
}

public void Delete(int id)
{
    List<Course> Courses = XMLTools.LoadListFromXMLSerializer<Course>(Config.s_courses_xml);
    if (Courses.RemoveAll(it => it.Id == id) == 0)
        throw new DalDoesNotExistException($"Course with ID={id} does Not exist");
    XMLTools.SaveListToXMLSerializer(Courses, Config.s_courses_xml);
}

public void DeleteAll()
{
    XMLTools.SaveListToXMLSerializer(new List<Course>(), Config.s_courses_xml);
}

Option 2: XElement
Example (also different entities):

static Student getStudent(XElement s)
{
    return new DO.Student()
    {
        Id = s.ToIntNullable("Id") ?? throw new FormatException("can't convert id"),
        Name = (string?)s.Element("Name") ?? "",
        Alias = (string?)s.Element("Alias") ?? null,
        IsActive = (bool?)s.Element("IsActive") ?? false,
        // CurrentYear = s.ToEnumNullable<Year>("CurrentYear") ?? Year.FirstYear,
        BirthDate = s.ToDateTimeNullable("BirthDate"),
        RegistrationDate = s.ToDateTimeNullable("RegistrationDate")
    };
}

public Student? Read(int id)
{
    XElement? studentElem = XMLTools.LoadListFromXMLElement(Config.s_students_xml)
                                  .Elements()
                                  .FirstOrDefault(st => (int?)st.Element("Id") == id);
    return studentElem is null ? null : getStudent(studentElem);
}

public Student? Read(Func<Student, bool> filter)
{
    return XMLTools.LoadListFromXMLElement(Config.s_students_xml)
                   .Elements()
                   .Select(s => getStudent(s))
                   .FirstOrDefault(filter);
}

public void Update(Student item)
{
    XElement studentsRootElem = XMLTools.LoadListFromXMLElement(Config.s_students_xml);

    (studentsRootElem.Elements()
        .FirstOrDefault(st => (int?)st.Element("Id") == item.Id)
        ?? throw new DO.DalDoesNotExistException($"Student with ID={item.Id} does Not exist"))
        .Remove();

    studentsRootElem.Add(new XElement("Student", createStudentElement(item)));

    XMLTools.SaveListToXMLElement(studentsRootElem, Config.s_students_xml);
}

I would like CourierImplementation to use the first option,
while OrderImplementation and DeliveryImplementation should use the second.

Reference for how an entity’s XML file should look once it has been filled (different entities).
Fields which are null do not appear:

xml version="1.0" encoding="utf-8"?>
<ArrayOfStudent>
  <Student>
    <Id>344165165</Id>
    <Name>Dani Levi</Name>
    <IsActive>false</IsActive>
    <BirthDate>2011-04-04T00:00:00</BirthDate>
  </Student>
  <Student>
    <Id>239894668</Id>
    <Name>Eli Amar</Name>
    <Alias>Eli AmarALIAS</Alias>
    <IsActive>true</IsActive>
    <BirthDate>2009-11-03T00:00:00</BirthDate>
  </Student>
  <Student>
    <Id>384822544</Id>
    <Name>Yair Cohen</Name>
    <Alias>Yair CohenALIAS</Alias>
    <IsActive>true</IsActive>
    <BirthDate>2019-10-27T00:00:00</BirthDate>
  </Student>
  <Student>
    <Id>200315134</Id>
    <Name>Ariela Levin</Name>
    <IsActive>true</IsActive>
    <BirthDate>2015-07-25T00:00:00</BirthDate>
  </Student>
</ArrayOfStudent>
*/

# Stage 4:
I now want to create the business layer for my project, on top of the data layer already present. the top level goal of my project is a delivery system which tracks the couriers, orders and deliveries belonging to the system.
in all steps adhere to the rules and requirements laid out in the GEMINI.md file (synthesize from the project requirement docs)
the business layer (BL folder) will contain:
The BO folder  for Business level logic entities
the BlApi older for the interfaces
the BlImplementation s for the interfaces' implementations

first, i want to fill in the BO folder - the business entities + enums and all exceptions expected in the business layer

Each Data layer entity should have a business equivalent. the business entities do not need to be exact one to one with the DL version - other properties may be added where it makes sense. e.g. in courier, a value for how long a courier was working for the company (derived from EmploymentStartTime and current date). i want at least one such addition per entity.
additionally, each business entity should have an EntityInList (with entity replaced by the appropriate entity name) used for when a more minimal view of the entity when the whole thing would be unnecessary or cumbersome.

add any additional business entities (with no data layer equivalent) that will be useful for the project.

next add the BlaPi interfaces + the BlImplementation files.
any complex logic should be placed in the appropriate Manager class in the Helpers folder. if it is generic and used by multiple implementations it should be placed in the Tools class

finally, create a testing class in BlTest for all functionality required by the project. structure it similarly to the DalTest.Program class

LINQ requirements:
Methods Using LINQ Extension Syntax (Method Syntax)
CourierManager.cs:
ReadAll
IsCourierInDelivery

DeliveryManager.cs:
ReadAll
PickUp
GetDeliveryByCourier
IsOrderTaken

OrderManager.cs
ReadAll
GetOrderTracking

LINQ Query Syntax (Linq-to-Objects):
let: Used in GetCourierDeliveryHistory, GetOpenOrders, PeriodicCouriersUpdate, and GetAvailableOrders.
select new: Used in GetCourierDeliveryHistory, GetCourierStatistics, PeriodicCouriersUpdate, and GetAvailableOrders.
grouping: Used in GetCourierStatistics (group d by d.DeliveryEndType).
sorting: Used in GetCourierDeliveryHistory (orderby d.DeliveryStartTime) and GetAvailableOrders (orderby order.OrderOpenTime).

# Stage 5:
I first gave Gemini the relevant sections of the Stage 5 instruction document (the rules and requirements) and told it to synthesize the rules and requirements it found into the GEMINI.md file. Then I told it to implement the instructions found thereign in the appropriate files using the prompt:

I'd like to implement the Presentation Layer (PL) now using WPF. Please follow the rules in the GEMINI.md file I created.
I need a MainWindow for the system clock and config, and list windows for Couriers, Orders, and Deliveries. For the lists, use DataGrid, not ListView.
I also need windows to add/update the entities, and a window to assign deliveries.
Please make sure to check the BO folder for the correct names of classes and properties instead of guessing.

example of later follow up prompt:
examine the window files in the Order folder of the PL project (added in the context). I need a few changes made, all adhering to the rules in the GEMINI.md file. 
first make sure the list window has columns for every property of OrderInList. 
second, i would like the list window to also look more professional and modern (instead of actual grid lines like it is now). this should include better placement of the text in 'cells' where appropriate. maybe center aligned instead of left? you decide. 
third - the list should be filterable by OrderStatus and/or DeliveryStatus. 
fourth - in the update version of the item view window that opens upon doubleclicking on the list, all properties of BO.Order should be shown. variables that are not updatable (e.g. for order opening time, all calculated properties) should not be able to be selected for change by the user. you can refer to the gemini file and the update method in OrderManager for specifics. in the item window opened by update, all fields which are not set by the user (e,g. order opening time which is set by the clock on creation) should be either invisible or just unchangeable, whichever is easier. 
in both cases, any property which cannot be changed should have some (professional, modern) visual indication of such in the window.