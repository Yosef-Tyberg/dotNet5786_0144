using Microsoft.VisualStudio.TestTools.UnitTesting;
using Helpers;
using BlApi;
using BO;
using System;
using System.Linq;
using DalApi;
// Generated by gemini, prompt in readme under stage 4

namespace BlUnitTests;

[TestClass]
public class ToolsTests
{
    // Coordinates for testing (approximate Jerusalem coordinates)
    private const double Lat1 = 31.7767;
    private const double Lon1 = 35.2345;
    private const double Lat2 = 31.7800;
    private const double Lon2 = 35.2300;

    private readonly IBl bl = BlApi.Factory.Get();
    private readonly IDal dl = DalApi.Factory.Get;

    private readonly DalApi.IConfig config = DalApi.Factory.Get.Config;
    [TestInitialize]
    public void Init()
    {
        AdminManager.InitializeDB();
        Tools.ClearCaches();
        Tools.SeedCoordinateCache();
    }

    #region Distance Tests

    [TestMethod]
    public void Test_GetAerialDistance_SamePoint_ReturnsZero()
    {
        double distance = Tools.GetAerialDistance(Lat1, Lon1, Lat1, Lon1);
        Assert.AreEqual(0, distance, 0.001, "Distance between same points should be 0.");
    }

    [TestMethod]
    public void Test_GetAerialDistance_DifferentPoints_ReturnsPositive()
    {
        double distance = Tools.GetAerialDistance(Lat1, Lon1, Lat2, Lon2);
        Assert.IsTrue(distance > 0, "Distance between different points should be positive.");
    }

    [TestMethod]
    public void Test_GetAerialDistance_Commutative()
    {
        double dist1 = Tools.GetAerialDistance(Lat1, Lon1, Lat2, Lon2);
        double dist2 = Tools.GetAerialDistance(Lat2, Lon2, Lat1, Lon1);
        Assert.AreEqual(dist1, dist2, 0.001, "Distance should be the same regardless of direction.");
    }

    [TestMethod]
    public void Test_GetDrivingDistance_ReturnsValidValue()
    {
        // Driving distance should be at least the aerial distance and within a reasonable range
        double aerial = Tools.GetAerialDistance(Lat1, Lon1, Lat2, Lon2);
        double driving = Tools.GetDrivingDistance(Lat1, Lon1, Lat2, Lon2);
        
        Assert.IsTrue(driving >= aerial, "Driving distance should be >= aerial distance.");
        Assert.IsTrue(driving < aerial * 5, "Driving distance should be within a reasonable range of aerial distance.");
    }

    [TestMethod]
    public void Test_GetWalkingDistance_ReturnsValidValue()
    {
        // Walking distance should be at least the aerial distance and within a reasonable range
        double aerial = Tools.GetAerialDistance(Lat1, Lon1, Lat2, Lon2);
        double walking = Tools.GetWalkingDistance(Lat1, Lon1, Lat2, Lon2);
        
        Assert.IsTrue(walking >= aerial, "Walking distance should be >= aerial distance.");
        Assert.IsTrue(walking < aerial * 7, "Walking distance should be within a reasonable range of aerial distance.");
    }

    [TestMethod]
    public void Test_GetAerialDistance_KnownDistance_ReturnsCorrectValue()
    {
        // Distance calculated using online tool for the given coordinates
        const double expectedDistance = 2.6; // km
        double actualDistance = Tools.GetAerialDistance(Lat1, Lon1, 31.8000, 35.2300);
        Assert.AreEqual(expectedDistance, actualDistance, 0.1, "Distance should be close to the known value.");
    }

    #endregion

    #region Coordinate Tests

    [TestMethod]
    public void Test_GetCoordinates_ValidAddress_ReturnsCoordinates()
    {
        // Assuming the implementation can handle a dummy or real address.
        string address = "Jerusalem";
        var (lat, lon) = Tools.GetCoordinates(address);
        
        // Check that we got valid numbers (not NaN) and they are non-zero
        Assert.IsFalse(double.IsNaN(lat));
        Assert.IsFalse(double.IsNaN(lon));
        Assert.IsTrue(lat != 0 || lon != 0);
    }

    [TestMethod]
    [ExpectedException(typeof(BlInvalidAddressException))]
    public void Test_GetCoordinates_NullAddress_ThrowsException()
    {
        Tools.GetCoordinates(null!);
    }

    [TestMethod]
    [ExpectedException(typeof(BlInvalidAddressException))]
    public void Test_GetCoordinates_EmptyAddress_ThrowsException()
    {
        Tools.GetCoordinates("");
    }
    
    [TestMethod]
    [ExpectedException(typeof(BlInvalidAddressException))]
    public void Test_GetCoordinates_WhitespaceAddress_ThrowsException()
    {
        Tools.GetCoordinates("   ");
    }

    [TestMethod]
    [ExpectedException(typeof(BlInvalidAddressException))]
    public void Test_GetCoordinates_InvalidAddress_ThrowsException()
    {
        Tools.GetCoordinates("asdfasdfasdf");
    }

    #endregion

    #region Schedule & Calculation Tests

    [TestMethod]
    public void Test_GetFastestType_ReturnsCorrectType()
    {

        config.AvgCarSpeedKmh = 50;
        config.AvgMotorcycleSpeedKmh = 100; // Fastest
        config.AvgBicycleSpeedKmh = 20;
        config.AvgWalkingSpeedKmh = 5;
        var result = Tools.GetFastestType(config);
        Assert.AreEqual(DO.DeliveryTypes.Motorcycle, result);
    }

    [TestMethod]
    public void Test_CalculateExpectedDeliveryTime_ReturnsValidTime()
    {
        var order = new DO.Order
        {
            Id = 1,
            Latitude = (config.Latitude ?? 31.7) + 0.01,
            Longitude = (config.Longitude ?? 35.2) + 0.01,
            OrderOpenTime = AdminManager.Now
        };

        var result = Tools.CalculateExpectedDeliveryTime(DO.DeliveryTypes.Car, order, config);
        Assert.IsTrue(result >= AdminManager.Now);
    }

    [TestMethod]
    public void Test_DetermineScheduleStatus_ReturnsOnTime_ForNewOrder()
    {
        var order = new BO.Order { Id = 0, CustomerFullName = "TestIII I", CustomerMobile = "0500000000", FullOrderAddress = "Ben Yehuda Street, Jerusalem", VerbalDescription = "Desc", Volume = 1, Weight = 1, Height = 1, Width = 1, OrderOpenTime = AdminManager.Now };
        bl.Order.Create(order);
        var id =dl.Order.ReadAll(o => o.CustomerFullName == "TestIII I").First();
        var status = Tools.DetermineScheduleStatus(id, config);
        Assert.AreEqual(ScheduleStatus.OnTime, status);
    }

    [TestMethod]
    public void Test_ScheduleStatus_ChangesOverTime()
    {
        // 1. Arrange: Setup dedicated data to avoid seed collisions
        int testCourierId = 777777777;

        // Create a guaranteed active courier who won't be deactivated
        dl.Courier.Create(new DO.Courier(
            Id: testCourierId,
            FullName: "Timing Tester",
            MobilePhone: "0551112222",
            Email: "timing@test.com",
            Password: "password",
            Active: true,
            DeliveryType: DO.DeliveryTypes.Car,
            EmploymentStartTime: bl.Admin.GetClock(),
            PersonalMaxDeliveryDistance: 5000.0
        ));

        // Create a fresh order
        var newOrder = new BO.Order
        {
            CustomerFullName = "Timing Customer",
            CustomerMobile = "0501112222",
            VerbalDescription = "Timing Test Order",
            FullOrderAddress = "Ben Yehuda Street, Jerusalem", // Uses Seeded Cache
            OrderType = OrderTypes.Pizza,
            Weight = 5,
            Volume = 2,
            Height = 10,
            Width = 10,
            OrderOpenTime = bl.Admin.GetClock()
        };
        bl.Order.Create(newOrder);
        var order = bl.Order.ReadAll().First(o => o.CustomerFullName == "Timing Customer");

        // Act 1: Pick up to start the delivery lifecycle
        bl.Delivery.PickUp(testCourierId, order.Id);

        // Fetch DO record for Tools.DetermineScheduleStatus check
        var doOrder = dl.Order.Read(order.Id);
        var doDelivery = dl.Delivery.ReadAll(d => d.OrderId == order.Id).First();

        // Assert 1: Initially OnTime
        Assert.AreEqual(ScheduleStatus.OnTime, Tools.DetermineScheduleStatus(doOrder, config, doDelivery));

        // 2. Act 2: Forward clock to the "AtRisk" window
        // MaxTime is the hard deadline. AtRisk starts (RiskRange) before MaxTime.
        var maxTime = order.OrderOpenTime + config.MaxDeliveryTimeSpan;

        // Target the middle of the Risk window with a 30s buffer for safety
        var timeToRiskMidpoint = (maxTime - bl.Admin.GetClock()) - (config.RiskRange / 2);
        bl.Admin.ForwardClock(timeToRiskMidpoint);

        // Assert 2: AtRisk
        Assert.AreEqual(ScheduleStatus.AtRisk, Tools.DetermineScheduleStatus(dl.Order.Read(order.Id), config, doDelivery));

        // 3. Act 3: Forward past the maximum deadline
        // Moving forward by the full RiskRange + 5 minutes ensures we are well past Late
        bl.Admin.ForwardClock(config.RiskRange.Add(TimeSpan.FromMinutes(5)));

        // Assert 3: Late
        Assert.AreEqual(ScheduleStatus.Late, Tools.DetermineScheduleStatus(dl.Order.Read(order.Id), config, doDelivery));
    }
    #endregion
}
