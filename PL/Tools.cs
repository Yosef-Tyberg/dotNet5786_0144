﻿﻿﻿// Generated by Gemini. Prompt is in the Readme under Stage 5
﻿using System;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Reflection;
using System.Text;

namespace PL;

// Static helper class for common UI operations
internal static class Tools
{
    public static void ExecuteSafeAction(Window window, Action action, string successMessage = "")
    {
        try
        {
            action();
            if (!string.IsNullOrEmpty(successMessage))
            {
                MessageBox.Show(window, successMessage, "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            window.Close();
        }
        catch (Exception ex)
        {
            MessageBox.Show(window, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }

    /// <summary>
    /// Helper to open a window of a specific type.
    /// If a window of that type is already open, it can either be activated or replaced.
    /// </summary>
    /// <remarks>
    /// This prevents multiple instances of the same window (e.g., multiple Courier Lists) from cluttering the screen.
    /// </remarks>
    /// <typeparam name="T">The type of the window.</typeparam>
    /// <param name="creator">Function to create a new instance of the window.</param>
    /// <param name="predicate">Optional filter to find a specific instance of the window (e.g. by mode).</param>
    /// <param name="replace">If true, closes the existing window before opening a new one.</param>
    public static void OpenWindow<T>(Func<T>? creator = null, Func<T, bool>? predicate = null, bool replace = false) where T : Window
    {
        // Search existing windows in the application for type T
        var query = Application.Current.Windows.OfType<T>();
        if (predicate != null)
            query = query.Where(predicate);

        var window = query.FirstOrDefault();
        
        // If found, either replace it or bring it to front
        if (window != null)
        {
            if (replace)
            {
                window.Close();
                if (creator != null)
                {
                    var newWindow = creator();
                    newWindow.Show();
                    newWindow.Activate();
                }
            }
            else
            {
                window.Activate();
                if (window.WindowState == WindowState.Minimized)
                    window.WindowState = WindowState.Normal;
            }
        }
        else
        // If not found, create a new one
        {
            if (creator != null)
            {
                var newWindow = creator();
                newWindow.Show();
                newWindow.Activate();
            }
        }
    }

    /// <summary>
    /// Recursively checks if a DependencyObject and its children have any validation errors.
    /// </summary>
    public static bool IsValid(DependencyObject parent)
    {
        if (Validation.GetHasError(parent))
            return false;

        // Validate all the bindings on the children
        for (int i = 0; i != VisualTreeHelper.GetChildrenCount(parent); ++i)
        {
            DependencyObject child = VisualTreeHelper.GetChild(parent, i);
            if (!IsValid(child)) { return false; }
        }
        return true;
    }

    /// <summary>
    /// Generic method to compare two objects of the same type to check if any properties have changed.
    /// </summary>
    /// <typeparam name="T">The type of the objects.</typeparam>
    /// <param name="oldObj">The original object.</param>
    /// <param name="newObj">The modified object.</param>
    /// <param name="ignoreProperties">List of property names to ignore during comparison.</param>
    /// <returns>True if any non-ignored property has changed; otherwise, false.</returns>
    public static bool IsInstanceChanged<T>(T oldObj, T newObj, params string[] ignoreProperties)
    {
        if (oldObj == null && newObj == null) return false;
        if (oldObj == null || newObj == null) return true;

        var properties = typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance);
        // Use LINQ to check if any property value differs between the two objects
        return properties
            .Where(prop => ignoreProperties == null || !ignoreProperties.Contains(prop.Name))
            .Any(prop => !Equals(prop.GetValue(oldObj), prop.GetValue(newObj)));
    }

    /// <summary>
    /// Recursively collects validation error messages from the visual tree.
    /// This aggregates errors flagged by ValidationRules (e.g., format errors) so we can display them in a MessageBox.
    /// </summary>
    /// <param name="parent">The root element to start searching from.</param>
    /// <returns>A string containing all validation error messages, or empty string if none.</returns>
    public static string GetUiValidationErrors(DependencyObject parent)
    {
        StringBuilder sb = new StringBuilder();
        GetErrorsRecursive(parent, sb);
        return sb.ToString();
    }

    /// <summary>
    /// Reverts specific properties on a target object to their values from a source object,
    /// based on a dictionary of validation errors (where keys are property names).
    /// </summary>
    /// <typeparam name="T">The type of the object.</typeparam>
    public static void RevertInvalidProperties<T>(T target, T source, System.Collections.Generic.Dictionary<string, string> errors)
    {
        _ = errors.All(error =>
        {
            var prop = typeof(T).GetProperty(error.Key);
            if (prop != null && prop.CanWrite)
            {
                prop.SetValue(target, prop.GetValue(source));
            }
            return true;
        });
    }

    // Helper to traverse the visual tree and accumulate errors
    private static void GetErrorsRecursive(DependencyObject parent, StringBuilder sb)
    {
        if (Validation.GetHasError(parent))
        {
            foreach (var error in Validation.GetErrors(parent))
                if (error.ErrorContent != null) sb.AppendLine($"- {error.ErrorContent}");
        }

        for (int i = 0; i != VisualTreeHelper.GetChildrenCount(parent); ++i)
        {
            GetErrorsRecursive(VisualTreeHelper.GetChild(parent, i), sb);
        }
    }
}